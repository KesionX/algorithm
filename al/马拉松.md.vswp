vnote_backup_file_826537664 /Users/kejianfang/Documents/vnote_notebooks/vnotebook/算法/马拉松.md
# 马拉松
## 简介
马拉松算法用来求解最长回文串。

## 算法分析
根据回文的性质，p[i]的值基于以下三种情况得出：
### （1）j 的回文串有一部分在 id 的之外
![3838615507-58b966b7602b5_articlex](_v_images/20190404165821157_1596706233.png)
上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时p[i] = mx - i，即紫线。那么p[i]还可以更大么？答案是不可能！见下图：
![](_v_images/20190404170118343_1520320813.png)
假设右侧新增的紫色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线+两条紫线，矛盾，所以假设不成立，故p[i] = mx - i，不可以再增加一分。

### （2）j 回文串全部在 id 的内部
![](_v_images/20190404170431176_1121487097.png)
根据代码，此时p[i] = p[j]，那么p[i]还可以更大么？答案亦是不可能！见下图：
![](_v_images/20190404170729985_992316656.png)
假设右侧新增的红色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立，故p[i] = p[j]，也不可以再增加一分。

### （3）j 回文串左端正好与 id 的回文串左端重合
![](_v_images/20190404170926209_977538539.png)
根据代码，此时p[i] = p[j]或p[i] = mx - i，并且p[i]还可以继续增加，所以需要
```
while (s_new[i - p[i]] == s_new[i + p[i]]) 
    p[i]++;
```

[算法分析](https://segmentfault.com/a/1190000008484167)

## 实例
[LeetCode最长回文](https://leetcode.com/problems/longest-palindromic-substring/)